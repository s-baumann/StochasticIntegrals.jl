var documenterSearchIndex = {"docs":
[{"location":"api/#Internal-Functions","page":"API","title":"Internal Functions","text":"Pages = [\"api.md\"]","category":"section"},{"location":"api/#Main-Structs","page":"API","title":"Main Structs","text":"","category":"section"},{"location":"api/#Random-Number-Generation","page":"API","title":"Random Number Generation","text":"","category":"section"},{"location":"api/#Ito-Processes","page":"API","title":"Ito Processes","text":"","category":"section"},{"location":"api/#Helper-Functions","page":"API","title":"Helper Functions","text":"","category":"section"},{"location":"api/#Internal-Functions-2","page":"API","title":"Internal Functions","text":"","category":"section"},{"location":"api/#StochasticIntegrals.ItoIntegral","page":"API","title":"StochasticIntegrals.ItoIntegral","text":"A struct detailing an ito integral. It contains a UnivariateFunction detailing the integrand as well as a symbol detailing an id of the integral's processes.\n\nUsual (and most general) contructor is:\n\nItoIntegral(brownian_id_::Symbol, f_::UnivariateFunction)\n\nConvenience constructor for ItoIntegrals where the integrand is a flat function is:\n\nItoIntegral(brownian_id_::Symbol, variance_::Real)\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticIntegrals.ItoSet","page":"API","title":"StochasticIntegrals.ItoSet","text":"Creates an ItoSet. This contains :\n\nA correlation matrix of brownian motions.\nA vector giving the axis labels for this correlation matrix.\nA dict of ItoInterals. Here the keys should be ids for the ito integrals and the values should be ItoIntegrals.\n\nDetermine which Brownian processes are used in an array of ItoIntegrals.\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticIntegrals.StochasticIntegralsCovariance","page":"API","title":"StochasticIntegrals.StochasticIntegralsCovariance","text":"StochasticIntegralsCovariance\n\nThis is an abstract type which represents structs that represent covariances over spans of time. The concrete instances of this type should support extracting correlations, covariances, volatilities and random number generation.\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticIntegrals.ForwardCovariance","page":"API","title":"StochasticIntegrals.ForwardCovariance","text":"ForwardCovariance\n\nCreates an ForwardCovariance struct. This contains :\n\nAn Itoset.\nThe time from which the covariance period starts.\nThe time to which the covariance period extends to.\n\nAnd in the constructor the following items are generated and stored in the object:\n\nA covariance matrix\nLabels for the covariance matrix.\nThe cholesky decomposition of the covariance matrix.\nThe inverse of the covariance matrix.\nThe determinant of the covariance matrix.\n\nThe constructors are:\n\nForwardCovariance(ito_set_::ItoSet, from_::Real, to_::Real;\n                  calculate_chol::Bool = true, calculate_inverse::Bool = true, calculate_determinant::Bool = true)\nForwardCovariance(ito_set_::ItoSet, from::Union{Date,DateTime}, to::Union{Date,DateTime})\nForwardCovariance(old_ForwardCovariance::ForwardCovariance, from::Real, to::Real)\nForwardCovariance(old_ForwardCovariance::ForwardCovariance, from::Union{Date,DateTime}, to::Union{Date,DateTime})\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticIntegrals.SimpleCovariance","page":"API","title":"StochasticIntegrals.SimpleCovariance","text":"SimpleCovariance\n\nCreates an SimpleCovariance struct. This is a simplified version of ForwardCovariance and is designed for ItoIntegrals that are constant (so correlations do not need to be recalculated). This computational saving is the only advantage - ForwardCovariance is more general. It contains the same elements as a ForwardCovariance:\n\nAn Itoset\nThe time from which the covariance period starts.\nThe time to which the covariance period extends to.\n\nAnd in the constructor the following items are generated and stored in the object:\n\nA covariance matrix\nLabels for the covariance matrix.\nThe cholesky decomposition of the covariance matrix.\nThe inverse of the covariance matrix.\nThe determinant of the covariance matrix.\n\nThe constructors are:\n\nSimpleCovariance(ito_set_::ItoSet, from_::Real, to_::Real;\n     calculate_chol::Bool = true, calculate_inverse::Bool = true, calculate_determinant::Bool = true)\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticIntegrals.NumberGenerator","page":"API","title":"StochasticIntegrals.NumberGenerator","text":"A `NumberGenerator` must always return a vector of uniforms when called with the function `next!(::NumberGenerator)`.\nIt can contain whatever it wants as long as it does that method.\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticIntegrals.Mersenne","page":"API","title":"StochasticIntegrals.Mersenne","text":"A NumberGenerator wrapper for `MersenneTwister`. This makes pseudorandom numbers.\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticIntegrals.SobolGen","page":"API","title":"StochasticIntegrals.SobolGen","text":"A NumberGenerator wrapper for `SobolSeq`. This makes quasirandom numbers\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticIntegrals.Stable_RNG","page":"API","title":"StochasticIntegrals.Stable_RNG","text":"A NumberGenerator wrapper for `MersenneTwister`. This makes pseudorandom numbers.\n\n\n\n\n\n","category":"type"},{"location":"api/#Sobol.next!","page":"API","title":"Sobol.next!","text":"next!(number_generator::NumberGenerator)\n\nThis extracts a random draw given a number generator struct (like a SobolGen, Mersenne or Stable_RNG).\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.get_draws","page":"API","title":"StochasticIntegrals.get_draws","text":"get_draws(covar::ForwardCovariance; uniform_draw::Array{T,1} = rand(length(covar.covariance_labels_))) where T<:Real\n\nInputs\n\ncovar - An ForwardCovariance or SimpleCovariance struct that you want to draw from.\nuniform_draw- The draw vector (from the uniform distribution)\n\nReturns\n\nA Dict of draws.\n\n\n\n\n\nget_draws(covar::Union{ForwardCovariance,SimpleCovariance}, num::Integer; number_generator::NumberGenerator = Mersenne(MersenneTwister(1234), length(covar.covariance_labels_)), antithetic_variates = false)\n\nget pseudorandom draws from a ForwardCovariance struct. Other schemes (like quasirandom) can be done by inserting quasirandom numbers in as the uniformdraw. If the `antitheticvariates` control is set to true then every second set of draws will be antithetic to the previous.\n\nInputs\n\ncovar - An ForwardCovariance or SimpleCovariance struct that you want to draw from.\nnum- The number of draws you want\nnumber_generator- How you want to generate random draws.\nantithetic_variates - Do you want antithetic variate sampling.\n\nReturns\n\nA Vector of Dicts of draws.\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.get_draws_matrix","page":"API","title":"StochasticIntegrals.get_draws_matrix","text":"get_draws_matrix(covar::Union{ForwardCovariance,SimpleCovariance}, num::Integer; number_generator::NumberGenerator = Mersenne(MersenneTwister(1234), length(covar.covariance_labels_)), antithetic_variates = false)\n\nHigh-performance variant of get_draws that returns a pre-allocated matrix instead of an array of Dicts. Uses in-place matrix multiplication and reusable buffers to minimise allocations.\n\nInputs\n\ncovar - A ForwardCovariance or SimpleCovariance struct to draw from.\nnum - The number of draws you want.\nnumber_generator - How you want to generate random draws.\nantithetic_variates - Do you want antithetic variate sampling.\n\nReturns\n\nA Matrix{Float64} of size (num, dims) where each row is a draw and each column corresponds to an integral.\nA Vector{Symbol} of column labels matching covar.covariance_labels_.\n\nWhen antithetic_variates = true, num is rounded so that the returned matrix has 2 * round(num/2) rows, with rows 2i-1 and 2i summing to zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.get_zero_draws","page":"API","title":"StochasticIntegrals.get_zero_draws","text":"get_zero_draws(covar::ForwardCovariance)\n\nget a draw of zero for all ItoIntegrals. This may be handy for bug hunting.\n\nInputs\n\ncovar - the ForwardCovariance struct that you want zero draws from\n\nOutputs\n\nA Dict of zero draws\n\n\n\n\n\nget_zero_draws(covar::ForwardCovariance, num::Integer)\n\nget an array of zero draws for all ItoIntegrals. May be handy for bug hunting.\n\nInputs\n\ncovar - the ForwardCovariance struct that you want zero draws from\nnum - The number of zero draws you want.\n\nOutputs\n\nA Vector of Dicts of zero draws\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.ItoProcess","page":"API","title":"StochasticIntegrals.ItoProcess","text":"A struct representing an Itoprocess.\n\nMembers\n\nt0 - The initial time of the ItoProcess\nvalue - The initial value of the ItoProcess\ndrift - The drift of the ItoProcess.\nstochastic - The stochastic process.\n\n\n\n\n\n","category":"type"},{"location":"api/#StochasticIntegrals.evolve!","page":"API","title":"StochasticIntegrals.evolve!","text":"evolve!(itoprocess::ItoProcess, stochastic::Real, new_time::Real)\n\nEvolve the ItoProcess forward. This changes the time (t0) as well as the value.\n\nInputs\n\nitoprocess - The ItoProcess to be evolved.\nstochastic - A draw from the ItoIntegral.\nnew_time - The new time.\n\nReturn\n\nNothing. It changes the input ItoProcess\n\n\n\n\n\nevolve!(itoprocesses::Union{Dict{Symbol,ItoProcess{R}},Dict{Symbol,ItoProcess}}, stochastics::Union{Dict{Symbol,R},Dict{Symbol,Real}}, new_time::Real) where R<:Real\n\nEvolve the ItoProcess forward. This changes the time (t0) as well as the value.\n\nInputs\n\nitoprocesses - A Dict of ItoProcesses\nstochastic - A Dict of draws from the ItoIntegral.\nnew_time - The new time.\n\nReturn\n\nNothing. It changes the input ItoProcess\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.evolve_covar_and_ito_processes!","page":"API","title":"StochasticIntegrals.evolve_covar_and_ito_processes!","text":"evolve_covar_and_ito_processes!(itoprocesses::Union{Dict{Symbol,ItoProcess{R}},Dict{Symbol,ItoProcess}}, covar::ForwardCovariance, new_time::Real; number_generator::NumberGenerator) where R<:Real\n\nEvolve the ItoProcesses forward.\n\nInputs\n\nitoprocesses - A Dict of ItoProcesses\ncovar - The covariance matrix.\nnew_time - The new time.\nnumber_generator - The number generator\n\nReturn\n\nThe updated ItoProcesses\nThe Covariance matrix\n\n\n\n\n\nevolve_covar_and_ito_processes!(itoprocesses::Union{Dict{Symbol,ItoProcess{R}},Dict{Symbol,ItoProcess}}, covar::SimpleCovariance, new_time::Real; number_generator::NumberGenerator) where R<:Real\n\nEvolve the ItoProcesses forward.\n\nInputs\n\nitoprocesses - A Dict of ItoProcesses\ncovar - The covariance matrix.\nnew_time - The new time.\nnumber_generator - The number generator\n\nReturn\n\nThe updated ItoProcesses\nThe Covariance matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.make_ito_process_syncronous_time_series","page":"API","title":"StochasticIntegrals.make_ito_process_syncronous_time_series","text":"make_ito_process_syncronous_time_series(ito_processes::Union{Dict{Symbol,ItoProcess{T}},Dict{Symbol,ItoProcess}},\n                                                 covar::Union{ForwardCovariance,SimpleCovariance}, timegap::R, total_number_of_ticks::Integer;\n                                                 number_generator::NumberGenerator = Mersenne(MersenneTwister(2), length(collect(keys(ito_processes))))) where R<:Real where T<:Real\n\nEvolve the ItoProcesses forward.\n\nInputs\n\nitoprocesses - A Dict of ItoProcesses\ncovar - The covariance matrix.\ntimegap - The time gap between ticks.\ntotal_number_of_ticks - The total number of ticks.\nnumber_generator The NumberGenerator used for the RNG.\n\nReturn\n\nA DataFrame with the ticks.\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.make_ito_process_non_syncronous_time_series","page":"API","title":"StochasticIntegrals.make_ito_process_non_syncronous_time_series","text":"make_ito_process_non_syncronous_time_series(ito_processes::Union{Dict{Symbol,ItoProcess{R}},Dict{Symbol,ItoProcess}},\n                                                 covar::Union{ForwardCovariance,SimpleCovariance}, update_rates::Union{OrderedDict{Symbol,D},Dict{Symbol,D},OrderedDict{Symbol,Distribution},Dict{Symbol,Distribution}},\n                                                 total_number_of_ticks::Integer;\n                                                 timing_twister::Union{StableRNG,MersenneTwister} = MersenneTwister(1),\n                                                 ito_number_generator::NumberGenerator = Mersenne(MersenneTwister(2), length(collect(keys(ito_processes))))\n                                                 ) where R<:Real where D<:Distribution\n\nEvolve the ItoProcesses forward.\n\nInputs\n\nitoprocesses - A Dict of ItoProcesses\ncovar - The covariance matrix.\nupdate_rates - The update rates of the exponential waiting times between ticks for each asset.\ntotal_number_of_ticks - The total number of ticks.\nito_twister The MersenneTwister used for the RNG.\n\nReturn\n\nA DataFrame with the ticks.\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.volatility","page":"API","title":"StochasticIntegrals.volatility","text":"volatility(ito::ItoIntegral, on::Union{Date,DateTime})\n\nGet the volatility of an ItoIntegral on a certain date.\n\nInputs\n\nito - The ItoIntegral you want the volatility for.\non - What instant do you want the volatility for.\n\nOutputs\n\nA scalar\n\n\n\n\n\nvolatility(ito::ItoSet, ito_integral_id::Symbol, on::Union{Date,DateTime})\n\nGet volatility of an ito_integral on a date.\n\nInputs\n\nito - An ItoSet that you want the volatility for.\nito_integral_id - The key of the ito dict that you are interested in\non The time or instant you want the volatility for.\n\nReturns\n\nA scalar\n\n\n\n\n\nvolatility(covar::ForwardCovariance, index::Integer, on::Union{Date,DateTime})\nvolatility(covar::ForwardCovariance, id::Symbol, on::Union{Date,DateTime})\n\nGet the volatility of an ForwardCovariance on a date.\n\nInputs\n\ncovar - An ForwardCovariance that you want the volatility for.\nindex - The key of the ito dict that you are interested in\non The time or instant you want the volatility for.\n\nReturns\n\nA scalar\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.variance","page":"API","title":"StochasticIntegrals.variance","text":"variance(ito::ItoIntegral, from::Real, to::Real)\nvariance(ito::ItoIntegral, base::Union{Date,DateTime}, from::Union{Date,DateTime}, to::Union{Date,DateTime})\n\nGet the variance of an ItoIntegral from one point of time to another.\n\nInputs\n\nito - The ItoIntegral you want the variance for.\nfrom - The time at which the integration starts.\nto - The time at which the integration ends.\n\nOutputs\n\nA scalar\n\n\n\n\n\nvariance(covar::ForwardCovariance, id::Symbol)\nvariance(covar::ForwardCovariance, index::Integer)\n\nGet the variance of an ForwardCovariance over a period.\n\nInputs\n\ncovar - An ForwardCovariance that you want the variance for.\nid or index - The key/index of the ito dict that you are interested in\n\nReturns\n\nA scalar\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.covariance","page":"API","title":"StochasticIntegrals.covariance","text":"covariance(ito1::ItoIntegral,ito2::ItoIntegral, from::Real, to::Real, gaussian_correlation::Real)\ncovariance(ito1::ItoIntegral,ito2::ItoIntegral, base::Union{Date,DateTime}, from::Union{Date,DateTime}, to::Union{Date,DateTime}, gaussian_correlation::Real)\n\nGet the covariance of two ItoIntegrals over a certain period given the underlying Brownian processes have a correlation of gaussian_correlation.\n\nInputs\n\nito1 - The first ItoIntegral\nito2 - The second ItoIntegral\nfrom - The start of the period\nto - The end of the period\ngaussian_correlation - The correlation between the brownians for each of the two itos. This should be in the range [-1,1].\non - What instant do you want the volatility for.\n\nOutputs\n\nA scalar\n\n\n\n\n\ncovariance(covar::ForwardCovariance, index_1::Integer, index_2::Integer)\ncovariance(covar::ForwardCovariance, id1::Symbol, id2::Symbol)\n\nGet the covariance of two ito integrals in a ForwardCovariance over a period.\n\nInputs\n\ncovar - An ForwardCovariance that you want the covariance for.\nindex_1 or id1 - The key/index of the first ito that you are interested in\nindex_2 or id2 - The key/index of the second ito that you are interested in\n\nReturns\n\nA scalar\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.correlation","page":"API","title":"StochasticIntegrals.correlation","text":"correlation(ito::ItoSet, index1::Integer, index2::Integer)\ncorrelation(ito::ItoSet, brownian_id1::Symbol, brownian_id2::Symbol)\n\nGet correlation between brownian motions in an ItoSet.\n\nInputs\n\nito - An ItoSet that you want the correlation for two itos within.\nindex1 or brownian_id1 - The index/key for the first ito integral.\nindex2 or brownian_id2 - The index/key for the second ito integral.\n\nReturns\n\nA scalar\n\n\n\n\n\ncorrelation(covar::ForwardCovariance, index_1::Integer, index_2::Integer)\ncorrelation(covar::ForwardCovariance, id1::Symbol, id2::Symbol)\n\nGet the correlation of two ItoIntegrals over a period.\n\nInputs\n\ncovar - An ForwardCovariance that you want the correlation for.\nindex_1 or id1 - The key/index of the first ito that you are interested in\nindex_2 or id2 - The key/index of the second ito that you are interested in\n\nReturns\n\nA scalar\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.pdf","page":"API","title":"StochasticIntegrals.pdf","text":"pdf(covar::ForwardCovariance, coordinates::Dict{Symbol,Real})\n\nget the value of the pdf at some coordinates. Note that it is assumed that the mean of the multivariate gaussian is the zero vector.\n\nInputs\n\ncovar - the ForwardCovariance struct that you want to evaluate the pdf\ncoordinates - The coordinates you want to examine.\n\nOutputs\n\nA scalar\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.make_covariance_matrix","page":"API","title":"StochasticIntegrals.make_covariance_matrix","text":"make_covariance_matrix(ito_set_::ItoSet, from::Real, to::Real)\n\nMake a covariance matrix given an ItoSet and a period of time. This returns a Hermitian covariance matrix as well as a vector of symbols representing the axis labelling on this Hermitian.\n\nInputs\n\nito_set_ - An ItoSet you want to make a covariance matrix from.\nfrom - The (numeric) time from which the covariance span starts.\nto - The (numeric) time at which the covariance span ends.\n\nReturns\n\nA Hermitian covariance matrix.\nA Vector{Symbol} of labels for the covariance matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.log_likelihood","page":"API","title":"StochasticIntegrals.log_likelihood","text":"log_likelihood(covar::ForwardCovariance, coordinates::Dict{Symbol,Real})\n\nget the log likelihood at some coordinates. Note that it is assumed that the mean of the multivariate gaussian is the zero vector.\n\nInputs\n\ncovar - the ForwardCovariance struct that you want to evaluate the log likelihood.\ncoordinates - The coordinates you want to examine.\n\nOutputs\n\nA scalar\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.brownians_in_use","page":"API","title":"StochasticIntegrals.brownians_in_use","text":"brownians_in_use(itos::Array{ItoIntegral,1}, brownians::Array{Symbol,1})\n\nDetermine which Browninan processes are used in an array of ItoIntegrals.\n\nInputs\n\nitos - A dict containing each of the ito integrals\nbrownians - All possible brownians\n\nOutputs\n\nA Vector of what brownians are in use in itos\nA Vector with the indices of these brownians.\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.update!","page":"API","title":"StochasticIntegrals.update!","text":"update!(sc::SimpleCovariance, from::Real, to::Real)\n\nThis takes a SimpleCovariance and updates it for a new  span in time. The new span in time is between from and to. For SimpleCovariance this is done by just adjusting the covariances for the new time span (with corresponding adjustments) to the cholesky, inverse, etc.\n\nThe corresponding technique for a ForwardCovariance (which is also a StochasticIntegralsCovariance) is to feed it into a new ForwardCovariance constructor which will recalculate for the new span.\n\nInputs\n\nsc - The SimpleCovariance struct.\nfrom - The time from which you want the covariance for.\nto - The time to which you want the covariance for.\n\nReturns\n\nNothing. It juts updates the sc struct you pass in as an input.\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.to_draws","page":"API","title":"StochasticIntegrals.to_draws","text":"to_draws(X::Array{T,2}; labels::Array{Symbol,1} = Symbol.(\"x\", 1:size(X)[2]))\nto_draws(dd::DataFrame; labels::Array{Symbol,1} =  Symbol.(names(dd)))\n\nConvert array or dataframe to a vector of Dicts containing draws.\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.to_dataframe","page":"API","title":"StochasticIntegrals.to_dataframe","text":"to_dataframe(X::Array{T,2}; labels::Array{Symbol,1} = Symbol.(\"x\", 1:size(X)[2]))\nto_dataframe(draws::Array{Dict{Symbol,T},1}; labels::Array{Symbol,1}  = collect(keys(draws[1])))\n\nConvert Arrays or Vectors of Dicts to a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.to_array","page":"API","title":"StochasticIntegrals.to_array","text":"to_array(draws::Array{Dict{Symbol,T},1}; labels::Array{Symbol,1}  = collect(keys(draws[1]))) where T<:Real\nto_array(dd::DataFrame; labels::Array{Symbol,1} =  Symbol.(names(dd)))\n\nConvert draws or a DataFrame to an array and a vector of column labels.\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.get_confidence_hypercube","page":"API","title":"StochasticIntegrals.get_confidence_hypercube","text":"get_confidence_hypercube(covar::ForwardCovariance, confidence_level::Real, data::Array{T,2}; tuning_parameter::Real = 1.0)\n\nThis returns the endpoints of a hypercube that contains confidence_level (%) of the dataset.\n\n\n\n\n\n","category":"function"},{"location":"api/#StochasticIntegrals.generate_conditioned_distribution","page":"API","title":"StochasticIntegrals.generate_conditioned_distribution","text":"generate_conditioned_dist(covar::ForwardCovariance, conditioning_draws::Array{Symbol,T}) where T<:Real\n\nGiven some subset of known stochastic integral values this generates a conditional multivariate normal distribution.\n\n\n\n\n\n","category":"function"},{"location":"#StochasticIntegrals","page":"Index","title":"StochasticIntegrals","text":"This generates covariance matrices and Cholesky decompositions for a set of stochastic integrals. At the moment it only supports Ito integrals. Users specify the UnivariateFunction that is the integrand of the Ito integral and a covariance matrix will be made of all such Ito integrals.\n\nThere are a large number of convenience functions. This includes finding the variance and instantaneous volatility of an ito integral; for extracting the terminal correlation & covariance of a pair of stochastic integrals over a period of time; for generation of random draws from the set of Ito integrals (either pseudorandom or quasirandom). Given a draw of stochastic integrals, it is also possible to find the density of the multivariate normal distribution at this point. See the testing files for code examples.","category":"section"},{"location":"#Example","page":"Index","title":"Example","text":"Consider that we have three different stochastic integrals. These are:\n\n$ \\int t^2 dZ $\n\n$ \\int 5t dZ $\n\n$ \\int e^{5 - t} dW $\n\nWhere Z and W are Brownian Motions.\n\nWe first write the integrands as univariate functions:\n\nusing StochasticIntegrals\nusing UnivariateFunctions\nA_integrand = PE_Function(1.0,0.0,0.0,2)\nB_integrand = PE_Function(5.0,0.0,0.0,1)\nC_integrand = PE_Function(1.0,-1.0,5.0,0)\n\nThen we get the correlation matrix of the two Brownian motions that we have. For simplicity lets consider the case that they are uncorrelated. We also specify the labels for these Brownian motions. In this case they will identify that the first row/column of the correlation matrix is for the :Z process and the second is for the :W process.\n\nusing LinearAlgebra\nbrownian_correlation_matrix = Hermitian(diagm(0 => ones(2)))\nbrownian_ids = [:Z, :W]\n\nNow we package the integrands of our stochastic integrals together with their corresponding Brownian motion ids to represent an Ito integral. We must also specify a new id for the stochastic integral to ensure that we know what row/column of the covariance matrix we create represents which integral.\n\nA  = ItoIntegral(:Z, A_integrand)\nB  = ItoIntegral(:Z, B_integrand)\nC  = ItoIntegral(:W, C_integrand)\nito_integrals = Dict{Symbol,ItoIntegral}([:A, :B, :C] .=> [A, B, C])\n\nNow we can place the Ito integrals together with the brownian motion correlation matrix to make an ItoSet.\n\nito_set = ItoSet(brownian_correlation_matrix, brownian_ids, ito_integrals)\n\nIn this format we can access the volatility of any of the Ito integrals at any point. We would usually be more interested in the statistical properties of the Ito integrals at a point forward in time. This can be done by generating a ForwardCovariance object. We must first specify the start and end limits on each integral. Below we look at the integrals  between 0.0 and 2.0. More generally time can be specified in Dates format. See testing files for more examples.\n\ncovar = ForwardCovariance(ito_set, 0.0, 2.0)\n\nAll of the hard work is done inside the above constructor. In particular a covariance matrix is generated as well as its inverse, Cholesky decomposition and determinant. These can be accessed directly in the normal way. Alternatively there are methods that can be called on a covar object to extract a correlation, covariance, variance or volatility using the stochastic integral ids. For instance to get the covariance between integrals A and B:\n\ncovariance_of_A_and_B = get_covariance(covar, :A, :B)\n\nIt is also possible to generate random numbers using either the get_normal_draws or get_sobol_normal_draws functions. For instance to get 10 pseudorandom realisations of these integrals:\n\ndraws = get_normal_draws(covar, 10)\n\nFor higher performance when generating many draws, get_draws_matrix returns a (Matrix{Float64}, Vector{Symbol}) tuple instead of an array of Dicts, avoiding per-draw allocations:\n\nmat, labels = get_draws_matrix(covar, 10)\n\nFor ascertaining the probability of the integrals jointing reaching some set of values there are the pdf and log_likelihood methods. For instance to find the log likelihood of the first draw we obtained above:\n\nlog_likelihood(covar, draws[1])\n\nSee the testing files for more code examples.","category":"section"},{"location":"#Data-conversions","page":"Index","title":"Data conversions","text":"StochasticIntegrals generates draws from stochastic integrals and places them into an array of Dicts. Sometimes it is easier to use data in an array or in a DataFrame. The to_draws, to_dataframe and to_array functions are convenience functions that convert datastructures between draws (Vector{Dict{Symbol,Float64}}), DataFrames and Vectors.","category":"section"}]
}
